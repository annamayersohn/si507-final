from bs4 import BeautifulSoup
import json

class Node:
    def __init__(self, type, txt, href, lang, clss, number, note, children):
        self.type = type
        self.txt = txt
        self.href = href
        self.lang = lang
        self.clss = clss
        self.number = number
        self.note = note
        self.children = children

    def get_class_list(self):
        '''Finds HTML class of each Node'''
        clss = self.clss.replace('_', ' ').strip()
        clss_list = clss.split()
        return clss_list

    def find_parent(self, node_list):
        '''Finds Node's parent Node in node_list and appends Node to parent's children property. Parent is the most recent Node for whom get_class_list returns same list as child minus final element.

        Parameters:
        node_list (list)
            List of all Node objects in the family tree

        Returns:
            None
        '''
        self_index = node_list.index(self)
        prev_nodes = node_list[:self_index]
        child_class_list = self.get_class_list()
        parent_class_list = child_class_list[:-1]
        for node in reversed(prev_nodes):
            if node.get_class_list() == parent_class_list:
                node.children.append(self)
                break

    def make_string(self):
        '''Turns Node object data into legible string'''
        if self.note:
            string = f'{self.txt} ({self.lang}, {self.note.strip("()")})'
        else:
            string = f'{self.txt} ({self.lang})'
        return string

    def make_dict(self, node_list):
        child_list = []
        for child in self.children:
            child_list.append(str(node_list.index(child)))
        node_dict = {'type': self.type, 'text': self.txt, 'href': self.href, 'usage': self.lang, 'html_class': self.clss, 'number': self.number, 'note': self.note, 'children': child_list}
        return node_dict

    def treemap_descendants(self, orig_parent, child_list, parent_list, rating_list):
        '''Formats data about a Node's children in correct format to generate a plotly treemap.

        Parameters:
        orig_parent (Node)
            The root node of the treemap.
        child_list (list)
            List of the nodes (strings generated by the make_string function) added to the treemap data so far.
        parent_list (list)
            List of the parents (strings generated by the make_string function) of the nodes in child_list.
        rating_list (list)
            List of the rating of each name in child_list. If there are any non-Name Nodes in child_list, None is appended to rating_list.

        Returns:
        child_list (list)
            List from child_list parameter, updated to contain current parent's children
        parent_list (list)
            List from parent_list parameter, updated to contain one instance of parent string for each child of parent.
        rating_list (list)
            List from rating_list parameter, updated to contain rating of each of current parent's children.
        '''
        #only gets called in main.py if len(child_list) =< 30
        siblings = self.children
        for child in siblings:
            child_list.append(child.make_string())
            parent_list.append(self.make_string())
            if type(child) == Name:
                rating_list.append(f'{child.rating}% of users like this name.')
            else:
                rating_list.append(None)
        for child in siblings:
            if child.children:
                child_list, parent_list, rating_list = child.treemap_descendants(orig_parent, child_list, parent_list, rating_list)
            else:
                pass
        return child_list, parent_list, rating_list


class Name(Node):
    def __init__(self, type, txt, href, lang, clss, number, note, gender, rating, children):
        super().__init__(type, txt, href, lang, clss, number, note, children)
        self.gender = gender
        self.rating = rating

    def make_string(self):
        '''Turns Name object data into legible string'''
        if self.note:
            string = f'{self.txt} ({self.lang}, {self.gender}, {self.note.strip("()")})'
        else:
            string = f'{self.txt} ({self.lang}, {self.gender})'
        return string

    def make_dict(self, node_list):
        child_list = []
        for child in self.children:
            child_list.append(node_list.index(child))
        node_dict = {'type': self.type, 'text': self.txt, 'href': self.href, 'usage': self.lang, 'html_class': self.clss, 'number': self.number, 'note': self.note, 'gender': self.gender, 'rating': self.rating, 'children': child_list}
        return node_dict

    def find_ancestry(self, node_list):
        '''
        Formats data about a Name's ancestry in correct format to generate a plotly table.

        Parameters:
        node_list (list)
            List of all Node objects in the family tree.

        Returns:
        columns (list)
            List of four lists. Each sub-list contains the data for one table column.
        '''

        columns = [[self.txt], [self.lang], [self.gender], [str(self.rating) + '%']]

        index = node_list.index(self)
        prev_nodes = node_list[:index]
        child = self
        while len(prev_nodes) > 0:
            for node in reversed(prev_nodes):
                if child in node.children:
                    columns[0].append(node.txt)
                    columns[1].append(node.lang)
                    if node.type == 'name':
                        columns[2].append(node.gender)
                        percent = str(node.rating) + '%'
                        columns[3].append(percent)
                    else:
                        columns[2].append('N/A')
                        columns[3].append('N/A')
                    child = node
                    prev_nodes = node_list[:node_list.index(child)]
        return columns

def create_nodes(soup, ratings):
    '''
    Isolates family tree (or first family tree, if more than one in soup) and creates Node or Name object for each node in family tree.

    Parameters:
    soup (BeautifulSoup)
        BeautifulSoup from HTML of BehindTheName the family tree page
    ratings (JSON dict)
        Dict where key is href and value is corresponding name's rating, captured by crawling to each name page

    Returns:
    nodes (list)
        List of Node/Name objects
    '''
    body = soup.find(id='body')
    families = body.find_all('table')
    main_family = families[0]
    tds = main_family.find_all('td')
    boxes = []

    for td in tds:
        node = td.find(class_='treenode')
        if node:
            boxes.append(td)

    nodes = []

    for box in boxes:
        clss = box['class'][0]
        nlc = box.find(class_='nlc')
        txt = nlc.text
        href = nlc['href']
        lang = box.find(class_='treeusage').text
        if box.find(class_='nn'):
            number = box.find(class_='nn').text
            txt = txt.strip(number)
            txt = txt.strip()
        else:
            number = None
        if href.split('/')[1] == 'name':    #If 1st element of href=='name', type is 'name'. Otherwise, type is formed from note.
            type = 'name'
            rating = ratings[href]
            if box.find(class_='masc') and box.find(class_='fem'):
                gender = 'unisex'
            elif box.find(class_='masc'):
                gender = 'masculine'
            else:
                gender = 'feminine'
            if box.find(class_='treenote'):
                note = box.find(class_='treenote').text
            else:
                note = None
            new_node = Name(type, txt, href, lang, clss, number, note, gender, rating, [])
        elif href.split('/')[1] != 'name':
            note = box.find(class_='treenote').text
            note_text = note.strip('()')
            note_words = note_text.split()
            type = '_'.join(note_words)
            new_node = Node(type, txt, href, lang, clss, number, note, [])
        nodes.append(new_node)

    return nodes

if __name__ == "__main__":
    with open('anna_soup.html', 'r') as filepath:
        html_text = filepath.read()
        soup = BeautifulSoup(html_text, 'html.parser')

    with open('anna_ratings.json', 'r') as filepath:
        ratings = json.load(filepath)

    nodes = create_nodes(soup, ratings)
    for node in nodes:
        node.find_parent(nodes)

    nodes_dict = {}
    for i in range(len(nodes)):
        nodes_dict[str(i)] = nodes[i].make_dict(nodes)

    with open('tree_json.json', 'w') as filepath:
        json.dump(nodes_dict, filepath)